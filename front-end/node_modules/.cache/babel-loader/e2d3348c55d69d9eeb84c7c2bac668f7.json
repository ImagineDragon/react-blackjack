{"ast":null,"code":"var jQuery = module.exports = require(\"./jquery-core.js\"),\n    core_rspace = /\\s+/;\n/**\n* jQuery Callbacks\n*\n* Code from: https://github.com/jquery/jquery/blob/master/src/callbacks.js\n*\n*/\n// String to Object options format cache\n\n\nvar optionsCache = {}; // Convert String-formatted options into Object-formatted ones and store in cache\n\nfunction createOptions(options) {\n  var object = optionsCache[options] = {};\n  jQuery.each(options.split(core_rspace), function (_, flag) {\n    object[flag] = true;\n  });\n  return object;\n}\n/*\n * Create a callback list using the following parameters:\n *\n *\toptions: an optional list of space-separated options that will change how\n *\t\t\tthe callback list behaves or a more traditional option object\n *\n * By default a callback list will act like an event callback list and can be\n * \"fired\" multiple times.\n *\n * Possible options:\n *\n *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n *\n *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n *\t\t\t\t\tvalues (like a Deferred)\n *\n *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n *\n *\tstopOnFalse:\tinterrupt callings when a callback returns false\n *\n */\n\n\njQuery.Callbacks = function (options) {\n  // Convert options from String-formatted to Object-formatted if needed\n  // (we check in cache first)\n  options = typeof options === \"string\" ? optionsCache[options] || createOptions(options) : jQuery.extend({}, options);\n\n  var // Last fire value (for non-forgettable lists)\n  memory,\n      // Flag to know if list was already fired\n  _fired,\n      // Flag to know if list is currently firing\n  firing,\n      // First callback to fire (used internally by add and fireWith)\n  firingStart,\n      // End of the loop when firing\n  firingLength,\n      // Index of currently firing callback (modified by remove if needed)\n  firingIndex,\n      // Actual callback list\n  list = [],\n      // Stack of fire calls for repeatable lists\n  stack = !options.once && [],\n      // Fire callbacks\n  fire = function fire(data) {\n    memory = options.memory && data;\n    _fired = true;\n    firingIndex = firingStart || 0;\n    firingStart = 0;\n    firingLength = list.length;\n    firing = true;\n\n    for (; list && firingIndex < firingLength; firingIndex++) {\n      if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {\n        memory = false; // To prevent further calls using add\n\n        break;\n      }\n    }\n\n    firing = false;\n\n    if (list) {\n      if (stack) {\n        if (stack.length) {\n          fire(stack.shift());\n        }\n      } else if (memory) {\n        list = [];\n      } else {\n        self.disable();\n      }\n    }\n  },\n      // Actual Callbacks object\n  self = {\n    // Add a callback or a collection of callbacks to the list\n    add: function add() {\n      if (list) {\n        // First, we save the current length\n        var start = list.length;\n\n        (function add(args) {\n          jQuery.each(args, function (_, arg) {\n            var type = jQuery.type(arg);\n\n            if (type === \"function\") {\n              if (!options.unique || !self.has(arg)) {\n                list.push(arg);\n              }\n            } else if (arg && arg.length && type !== \"string\") {\n              // Inspect recursively\n              add(arg);\n            }\n          });\n        })(arguments); // Do we need to add the callbacks to the\n        // current firing batch?\n\n\n        if (firing) {\n          firingLength = list.length; // With memory, if we're not firing then\n          // we should call right away\n        } else if (memory) {\n          firingStart = start;\n          fire(memory);\n        }\n      }\n\n      return this;\n    },\n    // Remove a callback from the list\n    remove: function remove() {\n      if (list) {\n        jQuery.each(arguments, function (_, arg) {\n          var index;\n\n          while ((index = jQuery.inArray(arg, list, index)) > -1) {\n            list.splice(index, 1); // Handle firing indexes\n\n            if (firing) {\n              if (index <= firingLength) {\n                firingLength--;\n              }\n\n              if (index <= firingIndex) {\n                firingIndex--;\n              }\n            }\n          }\n        });\n      }\n\n      return this;\n    },\n    // Control if a given callback is in the list\n    has: function has(fn) {\n      return jQuery.inArray(fn, list) > -1;\n    },\n    // Remove all callbacks from the list\n    empty: function empty() {\n      list = [];\n      return this;\n    },\n    // Have the list do nothing anymore\n    disable: function disable() {\n      list = stack = memory = undefined;\n      return this;\n    },\n    // Is it disabled?\n    disabled: function disabled() {\n      return !list;\n    },\n    // Lock the list in its current state\n    lock: function lock() {\n      stack = undefined;\n\n      if (!memory) {\n        self.disable();\n      }\n\n      return this;\n    },\n    // Is it locked?\n    locked: function locked() {\n      return !stack;\n    },\n    // Call all callbacks with the given context and arguments\n    fireWith: function fireWith(context, args) {\n      args = args || [];\n      args = [context, args.slice ? args.slice() : args];\n\n      if (list && (!_fired || stack)) {\n        if (firing) {\n          stack.push(args);\n        } else {\n          fire(args);\n        }\n      }\n\n      return this;\n    },\n    // Call all the callbacks with the given arguments\n    fire: function fire() {\n      self.fireWith(this, arguments);\n      return this;\n    },\n    // To know if the callbacks have already been called at least once\n    fired: function fired() {\n      return !!_fired;\n    }\n  };\n\n  return self;\n};","map":null,"metadata":{},"sourceType":"script"}