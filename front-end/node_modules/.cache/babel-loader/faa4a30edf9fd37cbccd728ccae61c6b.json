{"ast":null,"code":"/*!\n* jquery-deferred\n* Copyright(c) 2011 Hidden <zzdhidden@gmail.com>\n* MIT Licensed\n*/\n\n/**\n* Library version.\n*/\nvar jQuery = module.exports = require(\"./jquery-callbacks.js\"),\n    core_slice = Array.prototype.slice;\n/**\n* jQuery deferred\n*\n* Code from: https://github.com/jquery/jquery/blob/master/src/deferred.js\n* Doc: http://api.jquery.com/category/deferred-object/\n*\n*/\n\n\njQuery.extend({\n  Deferred: function Deferred(func) {\n    var tuples = [// action, add listener, listener list, final state\n    [\"resolve\", \"done\", jQuery.Callbacks(\"once memory\"), \"resolved\"], [\"reject\", \"fail\", jQuery.Callbacks(\"once memory\"), \"rejected\"], [\"notify\", \"progress\", jQuery.Callbacks(\"memory\")]],\n        _state = \"pending\",\n        _promise = {\n      state: function state() {\n        return _state;\n      },\n      always: function always() {\n        deferred.done(arguments).fail(arguments);\n        return this;\n      },\n      then: function then()\n      /* fnDone, fnFail, fnProgress */\n      {\n        var fns = arguments;\n        return jQuery.Deferred(function (newDefer) {\n          jQuery.each(tuples, function (i, tuple) {\n            var action = tuple[0],\n                fn = fns[i]; // deferred[ done | fail | progress ] for forwarding actions to newDefer\n\n            deferred[tuple[1]](jQuery.isFunction(fn) ? function () {\n              var returned = fn.apply(this, arguments);\n\n              if (returned && jQuery.isFunction(returned.promise)) {\n                returned.promise().done(newDefer.resolve).fail(newDefer.reject).progress(newDefer.notify);\n              } else {\n                newDefer[action + \"With\"](this === deferred ? newDefer : this, [returned]);\n              }\n            } : newDefer[action]);\n          });\n          fns = null;\n        }).promise();\n      },\n      // Get a promise for this deferred\n      // If obj is provided, the promise aspect is added to the object\n      promise: function promise(obj) {\n        return obj != null ? jQuery.extend(obj, _promise) : _promise;\n      }\n    },\n        deferred = {}; // Keep pipe for back-compat\n\n    _promise.pipe = _promise.then; // Add list-specific methods\n\n    jQuery.each(tuples, function (i, tuple) {\n      var list = tuple[2],\n          stateString = tuple[3]; // promise[ done | fail | progress ] = list.add\n\n      _promise[tuple[1]] = list.add; // Handle state\n\n      if (stateString) {\n        list.add(function () {\n          // state = [ resolved | rejected ]\n          _state = stateString; // [ reject_list | resolve_list ].disable; progress_list.lock\n        }, tuples[i ^ 1][2].disable, tuples[2][2].lock);\n      } // deferred[ resolve | reject | notify ] = list.fire\n\n\n      deferred[tuple[0]] = list.fire;\n      deferred[tuple[0] + \"With\"] = list.fireWith;\n    }); // Make the deferred a promise\n\n    _promise.promise(deferred); // Call given func if any\n\n\n    if (func) {\n      func.call(deferred, deferred);\n    } // All done!\n\n\n    return deferred;\n  },\n  // Deferred helper\n  when: function when(subordinate\n  /* , ..., subordinateN */\n  ) {\n    var i = 0,\n        resolveValues = core_slice.call(arguments),\n        length = resolveValues.length,\n        // the count of uncompleted subordinates\n    remaining = length !== 1 || subordinate && jQuery.isFunction(subordinate.promise) ? length : 0,\n        // the master Deferred. If resolveValues consist of only a single Deferred, just use that.\n    deferred = remaining === 1 ? subordinate : jQuery.Deferred(),\n        // Update function for both resolve and progress values\n    updateFunc = function updateFunc(i, contexts, values) {\n      return function (value) {\n        contexts[i] = this;\n        values[i] = arguments.length > 1 ? core_slice.call(arguments) : value;\n\n        if (values === progressValues) {\n          deferred.notifyWith(contexts, values);\n        } else if (! --remaining) {\n          deferred.resolveWith(contexts, values);\n        }\n      };\n    },\n        progressValues,\n        progressContexts,\n        resolveContexts; // add listeners to Deferred subordinates; treat others as resolved\n\n\n    if (length > 1) {\n      progressValues = new Array(length);\n      progressContexts = new Array(length);\n      resolveContexts = new Array(length);\n\n      for (; i < length; i++) {\n        if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {\n          resolveValues[i].promise().done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject).progress(updateFunc(i, progressContexts, progressValues));\n        } else {\n          --remaining;\n        }\n      }\n    } // if we're not waiting on anything, resolve the master\n\n\n    if (!remaining) {\n      deferred.resolveWith(resolveContexts, resolveValues);\n    }\n\n    return deferred.promise();\n  }\n});","map":null,"metadata":{},"sourceType":"script"}